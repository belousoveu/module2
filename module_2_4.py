numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]

not_primes = []  # создаем пустой список составных чисел

# method 1. Простой перебор
print('Метод 1. Определение простых чисел перебором')
for i in numbers:
    for j in range(2, i):  # В цикле проверяем что число имеет делитили то записываем его в "not_primes"
        if i % j == 0:
            not_primes.append(i)
            break
# Создаем список простых чисел путем "вычитания" из исходного множества, множества составных чисел и отдельно вычитаем
# {1} поскольку она не относится ни к простым, ни к составным числам
primes = list(set(numbers) - set(not_primes) - {1})
print(primes)
print(not_primes)

# method 2. Используем алгоритм Решето Эратосфена
print('Метод 2. Определение простых чисел с помощью алгоритма Решето Эратосфена')
primes_list = [True for i in numbers]  # Создаем список значений True по размеру равному исходному массиву чисел
primes_list[0] = False  # сразу убираем из списка значение 1, поскольку оно не является ни простым числом, ни составным
i = 2  # устанавливаем начальное значение итератора
# чтобы сократить число итераций цикла проверяем только делители которые меньше чем квадратный корень из последнего
# числа проверяемой последовательности
while i * i <= len(numbers):
    if primes_list[i - 1]:
        for j in range(i * i, len(numbers), i):
            primes_list[j - 1] = False  # вычеркиваем из "решета" делители (для этого используем в цикле шаг)
    i += 1
# создаем список простых чисел из тех элементов исходного массива, которым соответствуют значения True в "решете"
prime = [p for p in numbers if primes_list[p - 1]]
# Создаем список составных чисел путем "вычитания" из исходного множества, множества простых чисел и отдельно вычитаем
# {1} поскольку она не относится ни к простым, ни к составным числам
not_primes = list(set(numbers) - set(prime) - {1})
print(prime)
print(not_primes)
